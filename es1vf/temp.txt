A arquitetura de desenvolvimento de software não tem nenhuma influência num processo de desenvolvimento. [F]
A diferença básica entre agregação e composição é que na agregação o clico de vida do objeto parte é completamente dependente do clico de vida do objeto todo. [F]
A diferença entre a proposta do modelo de processo incremental para o modelo de processo em espiral é a característica de que no modelo incremental, cada incremento não necessariamente deve entregar alguma parte do software. [F]
A visão de processo, na UML, tem como objetivo detalhar aspectos importantes do processo de desenvolvimento a ser seguido. [F]
Ajustes em diagrama de classes de negócio, como herança, eventuais tratamento de associação via agregação e composição podem ser feitas em vários momentos do projeto. É natural que eventualmente estes ajustes sejam feitos durante a especificação de aspectos comportamentais do software. [V]
Algumas heranças são definidas não somente pelos requisitos e conceitos presentes dentro do escopo do software a ser desenvolvido, mas também pelo entendimento de qual contexto que o futuro software será está inserido. [V]
Alta coesão e baixo acoplamento são metas de um bom projeto. Por exemplo, alta coesão significa que um método de classe execute somente e tão somente a tarefa restrita, compatível com seu objetivo, exigindo pouca interação com outras estruturas. [N]
Alta coesão e baixo acoplamento são metas de um bom projeto. Por exemplo, alta coesão significa que um método de classe execute somente e tão somente a tarefa restrita, compatível com seu objetivo. [V]
Alta coesão e baixo acoplamento são metas de um bom projeto. Por exemplo, alta coesão significa que uma especificação detalhada de uma classe seja compatível com suas responsabilidades, conceitos e objetivos. [V]
Aspectos de aparência numa interface com o usuário, incluem a preocupação com a quantidade do código fonte, já que esta camada oferece inúmeras possibilidades de reuso. [F]
Atividades como realizar cronograma, acompanhar o andamento do projeto, distribuir responsabilidades entre os membros do projeto, são inerentes a gestão do projeto que qualquer processo de desenvolvimento deve prever. [V]
Boas práticas de modelagem indicam que é desaconselhável haver referência circular entre classes e/ou pacotes. [V]
Boas práticas de software indicam definição de estrutura de heranças em hierarquias equilibradas, onde especializações compartilham o mesmo nível de abstração. [V]
Camada de persistência são métodos presentes numa classe persistente cujo objeto é gravar as informações do objeto num meio estável qualquer, por exemplo, um banco de dados. [F]
Casos de heranças são definidos pelos requisitos e conceitos presentes dentro do escopo do software a  ser desenvolvido e pela conveniência que o programador vê em economizar código durante a programação. [F]
Classe abstrata é um tipo de classe auxiliar que aparece em modelagens um pra um, numa relação de agregação ou composição principalmente. [F]
Classe transiente é um tipo de classe persistente, onde suas instâncias podem ser gravadas em tabelas diferentes no SGBD. [F]
Classes de associação * p/ * são especificadas dependendo da natureza do relacionamento. Se o relacionamento possui atributos ou comportamentos, sim, se não, sua necessidade dependerá do projeto para camada de persistência. [V]
Classes de associação * p/ * são especificadas dependendo da natureza do relacionamento. Se o relacionamento possui atributos ou comportamentos, sim, se não, sua necessidade dependerá do projeto. [V]
Composição e agregação são tipos especiais de associação entre objetos. A composição, quando modelada, significa que o objeto parte tem seu ciclo de vida dependente do objeto todo. [V]
Concorrência é um aspecto da Arquitetura de Desenvolvimento para sistemas distribuídos, cujo o objetivo é tratar de como as estruturas de software suportarão acessos simultâneos aos mesmos recursos: tabelas, serviços (webservices, etc). [V]
Dentro de um processo de desenvolvimento com paradigma OO, para chegar ao diagrama de classes é necessário primeiramente fazer o modelo E-R. [F]
Dependência é um tipo especial de herança. [F]
Depuração é consequência de um teste. O objetivo é identificar a origem do erro para correção. [V]
Diz-se que um processo é iterativo pelo fato de haver muita interação entre usuários e equipe de desenvolvimento do software. [F]
Do ponto de vista de planejamento, a proposta do plano de iterações no processo unificado é mais formal que as iterações por sprints em processos mais ágeis. [V]
Em arquitetura distribuída, todas as classes de objetos definidas para aplicação são distribuídas. Um servidor de aplicação como o Jboss, no padrão J2EE, gera os stubs e skeletons para todas as classes. [F]
Em OO o modelo E-R para banco de dados relacional é definido a partir do diagrama de classes já definido. [V]
Em OO, a única origem para se efazer o diagrama de classes de negócio é a partir do protótipo de telas validado com o cliente. [F]
Em OO, o diagrama de classes de negócio é formado a partir do protótipo (pode ser um desenho em papel, feito durante detalhamento de um grupo de casos de uso) validado com o cliente. [F]
Embora um gerenciador de banco de dados ofereça controle de transação, é responsabilidade do analista definir, projetar e implementar o que é considerado uma transação na aplicação de negócio, para garantir a consistência de informações envolvidas na transação. [V]
Embora um gerenciador de banco de dados ofereça controle de transação, é responsabilidade do desenvolvedor projetar e implementar uma aplicação de forma que o banco de garanta os princípios (ACID) de transação. [V]
Entre as fases genéricas de qualquer processo de desenvolvimento, é na fase de definição que se define o modelo de dados. [F]
Entre as fases genéricas de qualquer processo de desenvolvimento, é na fase de desenvolvimento que se define o modelo de dados. [V]
Escalabilidade é a possibilidade que a aplicação desenvolvida oferece de permitir várias manutenções evolutivas ao longo de seu ciclo de vida. [F]
Java não implementa herança múltipla. [V]
Manter íntegro todos os artefatos gerados durante uma manutenção de sistemas é importante, mas não necessário, pois os artefatos gerados na análise e projeto só serviram para criar o novo software. [F]
Manutenção evolutiva consiste em realizar ajustes, decorrentes, por exemplo de troca do servidor de banco de dados. [F]
Mesmo aplicando padrões de projeto, respeitando responsabilidade de classes, incluindo classes que representam serviços, promovendo baixo acoplamento entre camadas de negócio e apresentação, é possível que a aplicação não consiga ser executada de forma distribuída se não houver uso de framework relacionado a servidor de aplicação. [V]
Modelo E-R é um artefato, geralmente realiazdo na fase de elaboração. [V]
Modelo E-R é um artefato, geralmente realizado em iterações de iniciação. [F]
Na manutenção de software uma das dificuldades pode ser quantificar o esforço e o custo da modificação a ser realizada, uma vez, que algumas variáveis como por exemplo arquitetura e estruturação do software pode influenciar no esforço. [V]
No modelo cliente/servidor onde o cliente é \"gordo\", se cria pool de conexões com o Banco de Dados como forma de maximizar o uso do gerenciador de banco de dados. [F]
No processo XP, pelo fato do sistema ser desenvolvido por duas pessoas que trabalham juntas o tempo todo, artefatos de projeto e gerenciamento de projeto podem ser descartados. [F]
Num teste unitário (teste de unidade) pode ser aplicado apenas o conceito de teste caixa branca. [F]
Num teste unitário (teste de unidade) pode ser aplicado o conceito de teste caixa branca ou teste caixa preta. [V]
Numa arquitetura cliente/servidor, o modelo de cliente-gordo estabelece o princípio que a aplicação da interface gráfica é executada totalmente no micro do usuário, enquanto a aplicação referente à camada de negócio e banco de dados sempre está em outro servidor. [F]
Numa arquitetura distribuída, o gerenciamento do ambiente computacional é simplificado em relação a um modelo de processamento centralizado, uma vez que as interfaces de administração são gráficas e os computadores servidores são de menor porte. [F]
Numa arquitetura em camadas, as classes do tipo entidade presentes na camada de apresentação, servem para buscar as informações disponíveis no banco de dados. Desta forma esta camada é capaz de mostrar as informações solicitadas pelo usuário. [F]
O conceito de Portal agrega complexidade adicional no desenvolvimento e administração de tecnologia de informação, uma vez que páginas de conteúdo estático, podem ser publicadas na mesma página, onde exista um portlet representando um caso de uso de aplicação. [V]
O controle transacional e todo aspecto relacionado a uma transação e suas propriedades são detalhes exclusivamente tratados pelo gerenciador de banco de dados, não afetando em nenhum aspecto a aplicação. [F]
O diagrama de atividades na UML, representa aspectos comportamentais que a solução (software) pode atender. [V]
O diagrama de classes de negócio representa o modelo estrutural e comportamental servindo para demonstrar o entendimento capturado durante o levantamento de requisitos. [F]
O diagrama de classes de negócio representa o modelo estrutural e também serve para demonstrar o entendimento capturado durante o levantamento de requisitos e guiando assim toda a estrutura do software a ser desenvolvido. [V]
O diagrama de classes de negócio representa o modelo estrutural e também serve para demonstrar o entendimento capturado durante o levantamento de requisitos. [V]
O diagrama de sequência da UML representa aspectos estruturais de como se deve programar um software. [F]
O processo unificado, entre suas propostas, como \"Dirigido por Casos de Uso\", teve como influência a UML. [V]
Pode-se identificar classes de negócio para um diagrama de classes de negócio a partir do protótipo de telas validado com o usuário. [V]
Polimorfismo é uma característica de OO, da qual facilita a criação de frameworks, componentes. [V]
Realizar a lista de requisitos funcionais em algum nível de abstração também é uma das atividades da fase de definição de qualquer processo de desenvolvimento. [V]
Relação de agregação é uma relação \"é um tipo\" enquanto herança, é uma relação \"todo/parte\". [F]
Reuso é uma técnica de programação, que evita escrever código repetido. [V]
RMI é um dos protocolos de comunicação entre objetos JAVA padrão EJB. [V]
RMI é um protocolo de comunicação entre objetos JAVA. [V]
RMI é um protocolo de comunicação entre simples objetos JAVA. [F]
Sobrecarga de operações é uma característica de codificação onde se implementa numa mesma classe métodos com nomes diferentes mas com parâmetros iguais. [F]
Teste caixa preta é um tipo de teste cujo objetivo é avaliar o software se ele está correto sob os aspectos funcionais, mas sem conhecer suas estruturas internas. [V]
Teste estrutural ou caixa preta é um tipo de teste cujo objetivo é avaliar o software se ele está correto sob os aspectos funcionais, mas sem conhecer suas estruturas internas. [F]
Teste é essencialmente uma atividade para detectar se o software construído (código fonte) não tem erros. [F]
Um caso de uso define uma atividade específica bem definida em que um ou vários atores participam. [V]
Um diagrama de classes é um produto tanto de análise quanto de projeto. [V]
Um dos desafios durante a manutenção de software é mudar totalmente a arquitetura de desenvolvimento do software, já que, o software é flexível e feito para isso. [F]
Um pacote (package) é um elemento de agrupamento, assim como classes, que agrupam atributos de um mesmo objeto. [V]
Um pacote (package) é um elemento de agrupamento. [V]
Um pacote (package) é um módulo do sistema a ser desenvolvido. [F]
Um processo de qualidade em desenvolvimento de software pressupõe que os diversos artefatos gerados durante o desenvolvimento de software possam ser verificados e validados, ou seja, possam ser homologáveis. [V]
Um protótipo de telas de um sistema é um artefato de projeto que serve para validar requisitos. [V]
Um relacionamento de agregação entre classes de pacotes diferentes não cria uma relação de dependência entre pacotes, somente entre as classes envolvidas. [F]
Um relacionamento de composição entre classes de pacotes diferentes cria uma relação de dependência entre os pacotes, mas um relacionamento de dependência não. [F]
Um relacionamento de composição entre classes de pacotes diferentes cria uma relação de dependência entre os pacotes. [V]
Um serviço em SOA (Arquitetura Orientada a Serviços) pode ser implementado de forma estruturada (numa linguagem estruturada inclusive). Desde que se projete uma interface estável entre o serviço e os clientes deste serviço. [V]
Um use-case define uma atividade específica bem definida em que um ou vários atores participam. [V]
Uma abstração representa uma realidade específica, sob um determinado foco. [V]
Uma aplicação monolítica é um estilo de projeto e implementação que o código fonte da interface com usuário está fortemente acoplado ao código fonte das regras de negócio e acesso a banco. [V]
Uma arquitetura define o QUE deve ser feito. A codificação define COMO deve ser feito. [F]
Uma camada contém componentes de software bem projetados, que são compostos por classes. A especificação e responsabilidades destas classes não precisam ser necessariamente compatíveis com o objetivo e responsabilidade geral de uma camada de software. [F]
Uma classe representa objetos do mesmo tipo. Portanto a especificação desta classe deve ser compatível com os conceitos associados a este objeto, não importando a que camada de software o mesmo corresponde. [N]
Uma classe representa objetos do mesmo tipo. Portanto a especificação desta classe deve ser compatível com os conceitos associados a este objeto. [V]
Uma classe transiente representa objetos cuja as informações não são guardadas em um banco de dados relacional, apenas em arquivo tipo texto. [F]
Uma das diferenças entre um serviço e um método de classe está na granularidade da operação implementada no método. [V]
Uma das finalidades das iterações no processo unificado é diminuir o risco de não conformidades com requisitos no desenvolvimento do software. [V]
Uma programação essencialmente orientada a eventos é uma forma de programação estruturada. [F]
Uma programação essencialmente orientada a eventos é uma forma de programação monolítica. [V]
Uma programação orientada a eventos é uma programação OO. [F]
Usabilidade/Navegabilidade, combinação de cores, reuso de código fonte, coesão do código, são apenas aspectos estruturais a serem considerados numa interface com o usuário. [F]
Verificação é uma atividade relacionada a TESTES, da qual o principal objetivo é verificar se os artefatos que estão sendo gerados estão compatíveis com os requisitos do negócio. [F]
É na fase de iniciação onde há especificação total de um sistema a ser construído. [F]
É na fase de iniciação onde há o detalhamento de todos os requisitos do sistema, assim na fase da elaboração cria-se os diagramas necessários a codificação do software. [F]
É possível, mesmo no modelo de processamento centralizado, adotar padrões de projeto em camadas. [V]
