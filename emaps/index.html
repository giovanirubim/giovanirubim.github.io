<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style type="text/css">
			* {
				font-family: monospace;
			}
			.canvas {
				box-shadow: -5px 5px 12px #aaa;
				display: inline-block;
				font-size: 0px;
			}
			div {
				margin-bottom: 5px;
			}
		</style>
		<title></title>
	</head>
	<body>
		<div>Source image: <select id="src"></select> <input type="button" id="draw" value="Draw"> <a href="" id="link">See image</a></div>
		<div>Project as: <select id="dst"></select> <input type="button" value="Project" id="project"/></div>
		<div>Mouse coord: <span id="coord">0, 0</span></div>
		<div><input type="text" id="targCoord" placeholder="Coordinates"> <input type="button" value="Target" id="target"></div>
		<div>Precision: <select id="precision"></select></div>
		<div>Canvas dimention: <input type="text" id="height"> x <span id="width"></span></div>
		<div class="canvas">
			<canvas></canvas>
			<canvas></canvas>
		</div>
	</body>
</html>
<script type="text/javascript">

	const EARTH_RADIUS = 6.371e6;

	const canvas = [ ...document.querySelectorAll('canvas') ];
	const ctx = canvas[0].getContext('2d');
	const lastCanvas = canvas.slice().reverse()[0];
	const lastCtx = lastCanvas.getContext('2d');

	const loadImage = (path) => new Promise((done) => {
		const img = document.createElement('IMG');
		img.onload = () => done(img);
		img.src = path;
	});

	const canvasToNormalX = (x, width) => x/width*2 - 1;
	const canvasToNormalY = (y, height) => (height - y)/height*2 - 1;
	const canvasToNormal = (x, y, width, height) => [
		canvasToNormalX(x, width),
		canvasToNormalY(y, height),
	];

	const normalToCanvasX = (x, width) => (x + 1)*width/2;
	const normalToCanvasY = (y, height) => height - (y + 1)/2*height;
	const normalToCanvas = (x, y, width, height) => [
		normalToCanvasX(x, width),
		normalToCanvasY(y, height),
	];

	const drawPixel = (x, y, color) => {
		ctx.fillStyle = color;
		ctx.fillRect(x, y, 1, 1);
	};

	const drawTarget = (x, y) => {
		lastCtx.clearRect(0, 0, lastCanvas.width, lastCanvas.height);
		lastCtx.strokeStyle = '#f00';
		lastCtx.lineWidth = 1;
		lastCtx.beginPath();
		lastCtx.moveTo(x, y - 5);
		lastCtx.lineTo(x, y + 5);
		lastCtx.moveTo(x - 5, y);
		lastCtx.lineTo(x + 5, y);
		lastCtx.stroke();
	};

	const resizeCanvas = (width, height) => {
		for (let i=0; i<canvas.length; ++i) {
			const item = canvas[i];
			item.width = width;
			item.height = height;
			if (i) {
				item.style.marginLeft = (-width) + 'px';
			}
		}
	};

	const averageColor = (colors) => {
		const res = [0, 0, 0];
		for (let color of colors) {
			res[0] += color[0];
			res[1] += color[1];
			res[2] += color[2];
		}
		res[0] = Math.round(res[0]/colors.length);
		res[1] = Math.round(res[1]/colors.length);
		res[2] = Math.round(res[2]/colors.length);
		return `rgb(${res})`;
	};

	;


	class ImageController {
		constructor(image) {
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			const { width, height } = image;
			canvas.width = width;
			canvas.height = height;
			ctx.drawImage(image, 0, 0);
			this.width = width;
			this.height = height;
			this.image = image;
			this.canvas = canvas;
			this.ctx = ctx;
		}
		rawColorAt(x, y) {
			x = Math.max(0, Math.round(x - 0.5));
			y = Math.max(0, Math.round(y - 0.5));
			const { width, height, ctx } = this;
			let { data } = ctx.getImageData(x, y, 1, 1);
			return data.slice(0, 3);
		}
		colorAt(x, y) {
			return `rgb(${this.rawColorAt(x, y)})`;
		}
		preciseColorAt(x, y) {
			const colors = [];
			if (precision === 1) {
				return this.colorAt(x, y);
			}
			const step = 1/(precision - 1);
			const ini = -.5 + step*.5;
			for (let dx=ini; dx<.5; dx+=step) {
				for (let dy=ini; dy<.5; dy+=step) {
					colors.push(this.rawColorAt(x + dx, y + dy));
				}
			}
			return averageColor(colors);
		}
		plotPixel(x, y, transform) {
			const { width, height } = canvas[0];
			const tWidth = this.width;
			const tHeight = this.height;
			let nx = canvasToNormalX(x + 0.5, width);
			let ny = canvasToNormalY(y + 0.5, height);
			[ nx, ny ] = transform(nx, ny);
			const tx = normalToCanvasX(nx, tWidth);
			const ty = normalToCanvasY(ny, tHeight);
			// const color = this.colorAt(tx, ty);
			const color = this.preciseColorAt(tx, ty);
			drawPixel(x, y, color);
		}
		*plotUpDown(transform) {
			const { width, height } = canvas[0];
			for (let y=0; y<height; ++y) {
				for (let x=0; x<width; ++x) {
					this.plotPixel(x, y, transform);
				}
				yield;
			}
		}
		plotArea(transform, startX, startY, width, height) {
			const endX = startX + width;
			const endY = startY + height;
			for (let y=startY; y<endY; ++y) {
				for (let x=startX; x<endX; ++x) {
					this.plotPixel(x, y, transform);
				}
			}
		}
		*plotAreas(transform, startX, startY, width, height, maxArea) {
			const area = width*height;
			if (area === 0) {
				return;
			}
			if (area <= maxArea) {
				this.plotArea(transform, startX, startY, width, height);
				yield;
				return;
			}
			const widths = [
				0,
				width - (width >> 1),
				width >> 1,
			];
			const heights = [
				0,
				height - (height >> 1),
				height >> 1,
			];
			for (let i=1; i<3; ++i) {
				const x = startX + widths[i - 1];
				const width = widths[i];
				for (let j=1; j<3; ++j) {
					const y = startY + heights[j - 1];
					const height = heights[j];
					yield* this.plotAreas(transform, x, y, width, height, maxArea);
				}
			}
		}

	}

	const drawImage = (image) => {
		ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas[0].width, canvas[0].height);
	};

	const sin = (deg) => Math.sin(deg*(Math.PI/180));
	const cos = (deg) => Math.cos(deg*(Math.PI/180));
	const tan = (deg) => Math.tan(deg*(Math.PI/180));

	const fixAngle = (angle) => angle < 180 ? angle : angle - 360;
	const acos = (cos) => Math.acos(cos)*(180/Math.PI);
	const asin = (sin) => Math.asin(sin)*(180/Math.PI);
	const atan = (tan) => Math.atan(tan)*(180/Math.PI);

	const getAngle = (ndx, ndy) => {
		return ndy >= 0 ? acos(ndx) : 360 - acos(ndx);
	};

	const maps = {
		nAzimuthal: {
			name: 'Azimuthal (north)',
			ratio: 1,
			toNormal: (lat, long) => {
				const radius = 0.5 - lat/180;
				const dx = sin(long)*radius;
				const dy = - cos(long)*radius;
				return [ dx, dy ];
			},
			toCoord: (dx, dy) => {
				const radius = Math.sqrt(dx*dx + dy*dy);
				if (radius === 0) return [ 90, 0 ];
				const lat = (1 - radius*2)*90;
				const ndx = - dy/radius;
				const ndy = dx/radius;
				const long = fixAngle(getAngle(ndx, ndy));
				return [ lat, long ];
			},
		},
		mercator: {
			name: "Mercator",
			ratio: 1,
			toNormal: (lat, long) => [
				long/180,
				Math.log(tan(45 + lat/2))/Math.PI,
			],
			toCoord: (nx, ny) => [
				(atan(Math.exp((ny)*Math.PI)) - 45)*2,
				nx*180,
			],
		},
		sAzimuthal: {
			name: 'Azimuthal (south)',
			ratio: 1,
			toNormal: (lat, long) => {
				const radius = 0.5 + lat/180;
				const dx = sin(long)*radius;
				const dy = cos(long)*radius;
				return [ dx, dy ];
			},
			toCoord: (dx, dy) => {
				const radius = Math.sqrt(dx*dx + dy*dy);
				if (radius === 0) return [ -90, 0 ];
				const lat = radius*180 - 90;
				const ndx = dy/radius;
				const ndy = dx/radius;
				const long = fixAngle(getAngle(ndx, ndy));
				return [ lat, long ];
			},
		},
		cAzimuthal: {
			name: 'Azimuthal (custom)',
			ratio: 1,
			toNormal: (lat, long) => {
				let [x, y, z] = coordToXyz(lat, long);
				const cos_long = cos(- targeted[1]);
				const sin_long = sin(- targeted[1]);
				const cos_lat = cos(- targeted[0]);
				const sin_lat = sin(- targeted[0]);
				[x, z] = [
					cos_long*x + sin_long*z,
					cos_long*z - sin_long*x,
				];
				[y, z] = [
					cos_lat*y + sin_lat*z,
					cos_lat*z - sin_lat*y,
				];
				[y, z] = [z, -y];
				const coord = xyzToCoord(x, y, z);
				return maps.nAzimuthal.toNormal(...coord);
			},
			toCoord: (nx, ny) => {
				let [lat, long] = maps.nAzimuthal.toCoord(nx, ny);
				let [x, y, z] = coordToXyz(lat, long);
				const cos_long = cos(targeted[1]);
				const sin_long = sin(targeted[1]);
				const cos_lat = cos(targeted[0]);
				const sin_lat = sin(targeted[0]);
				[y, z] = [-z, y];
				[y, z] = [
					cos_lat*y + sin_lat*z,
					cos_lat*z - sin_lat*y,
				];
				[x, z] = [
					cos_long*x + sin_long*z,
					cos_long*z - sin_long*x,
				];
				return xyzToCoord(x, y, z);
			},
		},
		gallpeters: {
			name: 'Gall-Peters',
			ratio: Math.PI/2,
			toNormal: (lat, long) => {
				const x = long/180;
				const y = sin(lat);
				return [ x, y ];
			},
			toCoord: (x, y) => {
				const lat = fixAngle(asin(y));
				const long = x*180;
				return [ lat, long ];
			},
		},
		grid: {
			name: 'Grid',
			ratio: 2,
			toNormal: (lat, long) => {
				return [ long/180, lat/90 ];
			},
			toCoord: (x, y) => {
				return [ y*90, x*180 ];
			},
		},
	};

	const mapNames = Object.values(maps).map((map) => map.name);

	const coordSpan = document.querySelector('#coord');
	let currentCoord = [0, 0];
	let line = null;
	const calcXyzMidPoint = (ax, ay, az, bx, by, bz) => {
		let x = (ax + bx)/2;
		let y = (ay + by)/2;
		let z = (az + bz)/2;
		const mul = 1/Math.sqrt(x*x + y*y + z*z);
		x *= mul;
		y *= mul;
		z *= mul;
		return [ x, y, z ];
	};
	const segmentLine = (ax, ay, az, bx, by, bz, maxDist) => {
		const dist = calcXyzDist(ax, ay, az, bx, by, bz);
		if (dist <= maxDist) {
			return [[ bx, by, bz ]];
		}
		const m = calcXyzMidPoint(ax, ay, az, bx, by, bz);
		const a = segmentLine(ax, ay, az, ...m, maxDist);
		const b = segmentLine(...m, bx, by, bz, maxDist);
		return [ ...a, ...b ];
	};
	const drawLine = () => {
		const ctx = lastCtx;
		const { a, b } = line;
		const { width, height } = canvas[0];
		const aXyz = coordToXyz(a.lat, a.long);
		const bXyz = coordToXyz(b.lat, b.long);
		const map = currentDstMap();
		ctx.clearRect(0, 0, width, height);
		ctx.strokeStyle = '#000';
		ctx.beginPath();
		ctx.moveTo(...normalToCanvas(a.nx, a.ny, width, height));
		segmentLine(...aXyz, ...bXyz, .05)
			.forEach(([x, y, z]) => {
				const coord = xyzToCoord(x, y, z);
				const [nx, ny] = map.toNormal(...coord);
				ctx.lineTo(...normalToCanvas(nx, ny, width, height));
			});
		ctx.stroke();
	};
	lastCanvas.onmousemove = (e) => {
		const x = e.offsetX;
		const y = e.offsetY;
		const nx = canvasToNormalX(x, canvas[0].width);
		const ny = canvasToNormalY(y, canvas[0].height);
		currentCoord = maps[selectDst.value].toCoord(nx, ny);
		coordSpan.innerHTML = currentCoord.join(', ');
		if ((e.buttons & 1) && line && line.end === false) {
			line.b.x = x;
			line.b.y = y;
			line.b.nx = nx;
			line.b.ny = ny;
			const [lat, long] = currentCoord;
			line.b.lat = lat;
			line.b.long = long;
			drawLine();
		}
	};
	lastCanvas.onmousedown = (e) => {
		if (e.button !== 0) {
			return;
		}
		const x = e.offsetX;
		const y = e.offsetY;
		const nx = canvasToNormalX(x, canvas[0].width);
		const ny = canvasToNormalY(y, canvas[0].height);
		const [lat, long] = maps[selectDst.value].toCoord(nx, ny);
		line = {
			end: false,
			a: { x, y, nx, ny, lat, long },
			b: { x, y, nx, ny, lat, long },
		};
	};
	lastCanvas.onmouseup = (e) => {
		if (e.button === 0 && line) {
			line.end = true;
		}
	};
	lastCanvas.ondblclick = (e) => {
		const x = e.offsetX;
		const y = e.offsetY;
		const nx = canvasToNormalX(x, canvas[0].width);
		const ny = canvasToNormalY(y, canvas[0].height);
		targeted = maps[selectDst.value].toCoord(nx, ny);
		const normal = maps[selectDst.value].toNormal(...targeted);
		drawTarget(x, y);
		document.querySelector('#targCoord').value = targeted.join(', ');
	};

	const maxProjectionArea = 0x1000;

	async function project(src, dst) {
		let img = await loadImage(`./${src}.jpg`);
		const controller = new ImageController(img);
		const gen = controller.plotAreas(
			(x, y) => {
				const coord = maps[dst].toCoord(x, y);
				return maps[src].toNormal(...coord);
			},
			0, 0,
			canvas[0].width,
			canvas[0].height,
			maxProjectionArea,
		);
		while (!gen.next().done) {
			await new Promise((done) => setTimeout(done, 0));
		}
	}

	function getSelectInnerHTML() {
		let html = '';
		for (let id in maps) {
			const { name } = maps[id];
			html += `<option value="${id}">${name}</option>`;
		}
		return html;
	}

	const currentSrcMap = () => maps[selectSrc.value];
	const currentDstMap = () => maps[selectDst.value];

	const selectHTML = getSelectInnerHTML();
	const selectSrc = document.querySelector('#src');
	const selectDst = document.querySelector('#dst');
	const spanWidth = document.querySelector('#width');
	selectSrc.innerHTML = selectHTML;
	selectDst.innerHTML = selectHTML;

	document.querySelector('#project').onclick = () => {
		const src = selectSrc.value;
		const dst = selectDst.value;
		project(src, dst);
	};

	let targeted = [0, 0];
	document.querySelector('#target').onclick = () => {
		const coord = document.querySelector('#targCoord')
			.value
			.split(/\s*,\s*/)
			.map(x => Number(x));
		targeted = coord;
		const normal = maps[selectDst.value].toNormal(...coord);
		const [ x, y ] = normalToCanvas(...normal, canvas[0].width, canvas[0].height);
		drawTarget(x, y);
	};

	document.querySelector('#draw').onclick = async () => {
		const url = `./${selectSrc.value}.jpg`;
		const image = await loadImage(url);
		drawImage(image);
	};

	const link = document.querySelector('#link');
	const inputHeight = document.querySelector('#height');

	function updateLink() {
		link.href = `./${selectSrc.value}.jpg`;
	}

	function updateCanvasSize() {
		const str = inputHeight.value;
		if (!str.match(/^\d+$/)) {
			return;
		}
		const height = Number(str);
		const map = maps[selectDst.value];
		const width = Math.round(map.ratio * height);
		spanWidth.innerText = width;
		resizeCanvas(width, height);
	}

	selectSrc.onchange = () => {
		updateLink();
	};
	selectDst.onchange = () => {
		updateCanvasSize();
	};
	inputHeight.onchange = () => {
		updateCanvasSize();
	};

	updateLink();
	inputHeight.value = '600';
	updateCanvasSize();

	const coordToXyz = (lat, long) => {
		const y = sin(lat);
		const rad = cos(lat);
		const x = sin(long)*rad;
		const z = cos(long)*rad;
		return [x, y, z];
	};

	const xyzToCoord = (x, y, z) => {
		const lat = asin(y);
		const rad = Math.sqrt(x*x + z*z);
		const long = rad === 0 ? 0 : (
			x >= 0? acos(z/rad) : -acos(z/rad)
		);
		return [ lat, long ];
	};

	const calcXyzDist = (ax, ay, az, bx, by, bz) => {
		const dx = bx - ax;
		const dy = by - ay;
		const dz = bz - az;
		return Math.sqrt(dx*dx + dy*dy + dz*dz);
	};

	const xyzDistToSurfDist = (xyzDist) => {
		const halfRadAngle = Math.asin(xyzDist/2);
		const radAngle = 2*halfRadAngle;
		return radAngle*EARTH_RADIUS;
	};

	const calcCoordSurfDist = (aLat, aLong, bLat, bLong) => {
		const [ax, ay, az] = coordToXyz(aLat, aLong);
		const [bx, by, bz] = coordToXyz(bLat, bLong);
		const xyzDist = calcXyzDist(ax, ay, az, bx, by, bz);
		return xyzDistToSurfDist(xyzDist);
	};

	let precision = 1;
	const selectPrecision = document.querySelector('#precision');
	selectPrecision.onchange = function () {
		precision = this.value*1;
	};
	selectPrecision.innerHTML = new Array(4)
		.fill()
		.map((_,i) => `<option value=${i+1}>${i + 1}</option>`)
		.join('');

</script>
